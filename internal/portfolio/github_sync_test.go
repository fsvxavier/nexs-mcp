package portfolio

import (
	"context"
	"crypto/sha256"
	"encoding/hex"
	"os"
	"strings"
	"testing"
	"time"

	"github.com/fsvxavier/nexs-mcp/internal/domain"
	"github.com/fsvxavier/nexs-mcp/internal/infrastructure"
	"github.com/stretchr/testify/assert"
	"github.com/stretchr/testify/require"
)

// Mock GitHub Client for testing
type mockGitHubClient struct {
	files map[string]*infrastructure.FileContent
	err   error
}

func (m *mockGitHubClient) ListRepositories(ctx context.Context) ([]*infrastructure.Repository, error) {
	return nil, m.err
}

func (m *mockGitHubClient) GetFile(ctx context.Context, owner, repo, path, branch string) (*infrastructure.FileContent, error) {
	if m.err != nil {
		return nil, m.err
	}
	file, ok := m.files[path]
	if !ok {
		return nil, nil
	}
	return file, nil
}

func (m *mockGitHubClient) CreateFile(ctx context.Context, owner, repo, path, message, content, branch string) (*infrastructure.CommitInfo, error) {
	if m.err != nil {
		return nil, m.err
	}
	m.files[path] = &infrastructure.FileContent{
		Path:    path,
		Content: content,
		SHA:     "mock-sha",
	}
	return &infrastructure.CommitInfo{SHA: "mock-commit-sha"}, nil
}

func (m *mockGitHubClient) UpdateFile(ctx context.Context, owner, repo, path, message, content, sha, branch string) (*infrastructure.CommitInfo, error) {
	if m.err != nil {
		return nil, m.err
	}
	m.files[path] = &infrastructure.FileContent{
		Path:    path,
		Content: content,
		SHA:     sha,
	}
	return &infrastructure.CommitInfo{SHA: "mock-commit-sha"}, nil
}

func (m *mockGitHubClient) DeleteFile(ctx context.Context, owner, repo, path, message, sha, branch string) error {
	if m.err != nil {
		return m.err
	}
	delete(m.files, path)
	return nil
}

func (m *mockGitHubClient) ListFilesInDirectory(ctx context.Context, owner, repo, path, branch string) ([]string, error) {
	if m.err != nil {
		return nil, m.err
	}
	var files []string
	for filePath := range m.files {
		files = append(files, filePath)
	}
	return files, nil
}

func (m *mockGitHubClient) ListAllFiles(ctx context.Context, owner, repo, branch string) ([]string, error) {
	return m.ListFilesInDirectory(ctx, owner, repo, "", branch)
}

func (m *mockGitHubClient) GetUser(ctx context.Context) (string, error) {
	return "testuser", m.err
}

func (m *mockGitHubClient) CreateRepository(ctx context.Context, name, description string, private bool) (*infrastructure.Repository, error) {
	return nil, m.err
}

func (m *mockGitHubClient) ParseRepoURL(url string) (owner, repo string, err error) {
	return "testuser", "test-repo", m.err
}

func setupTestRepo(t *testing.T) (*infrastructure.EnhancedFileElementRepository, string) {
	tmpDir, err := os.MkdirTemp("", "nexs-sync-test-*")
	require.NoError(t, err)

	repo, err := infrastructure.NewEnhancedFileElementRepository(tmpDir, 100)
	require.NoError(t, err)

	return repo, tmpDir
}

func createTestElement(elementType, author string) domain.Element {
	// Create a concrete element based on type using constructors
	// Note: ID is auto-generated by New* functions
	switch domain.ElementType(elementType) {
	case domain.PersonaElement:
		return domain.NewPersona("Test Persona", "Test description", "1.0.0", author)
	case domain.SkillElement:
		return domain.NewSkill("Test Skill", "Test description", "1.0.0", author)
	default:
		return domain.NewPersona("Test Element", "Test description", "1.0.0", author)
	}
}

func elementToStoredElement(element domain.Element) *infrastructure.StoredElement {
	return &infrastructure.StoredElement{
		Metadata: element.GetMetadata(),
	}
}

func hashContent(content string) string {
	hash := sha256.Sum256([]byte(content))
	return hex.EncodeToString(hash[:])
}

func TestGitHubSync_Push_Success(t *testing.T) {
	repo, tmpDir := setupTestRepo(t)
	defer os.RemoveAll(tmpDir)

	// Create test element
	element := createTestElement("persona", "testuser")
	err := repo.Create(element)
	require.NoError(t, err)
	elementID := element.GetID()

	t.Logf("Created element with ID: %s", elementID)
	t.Logf("Element metadata: %+v", element.GetMetadata())

	// Mock GitHub client
	mockClient := &mockGitHubClient{
		files: make(map[string]*infrastructure.FileContent),
	}

	// Create sync
	mapper := NewGitHubMapper(tmpDir)
	sync := NewGitHubSync(mockClient, repo, mapper, ConflictLocalWins)

	// Push
	ctx := context.Background()
	result, err := sync.Push(ctx, "testuser", "test-repo", "main")

	assert.NoError(t, err)
	assert.Equal(t, 1, result.Pushed)
	assert.Equal(t, 0, result.Pulled)
	assert.Len(t, result.Conflicts, 0)
	assert.Len(t, result.Errors, 0)

	// Verify file was created in mock
	expectedPathPrefix := "elements/testuser/persona/" + time.Now().Format("2006-01-02") + "/"
	found := false
	for path := range mockClient.files {
		if strings.HasPrefix(path, expectedPathPrefix) && strings.Contains(path, elementID) {
			found = true
			break
		}
	}
	assert.True(t, found, "Expected file with prefix %s and ID %s to be created", expectedPathPrefix, elementID)
}

func TestGitHubSync_Pull_Success(t *testing.T) {
	repo, tmpDir := setupTestRepo(t)
	defer os.RemoveAll(tmpDir)

	// Mock GitHub client with existing file
	yamlContent := `metadata:
  id: skill_TestSkill_20240101-120000
  type: skill
  name: Test Skill
  description: Test description
  version: 1.0.0
  author: testuser
  tags: []
  is_active: true
  created_at: 2024-01-01T00:00:00Z
  updated_at: 2024-01-01T00:00:00Z
`
	mockClient := &mockGitHubClient{
		files: map[string]*infrastructure.FileContent{
			"elements/testuser/skill/2024-01-01/skill_TestSkill_20240101-120000.yaml": {
				Path:    "elements/testuser/skill/2024-01-01/skill_TestSkill_20240101-120000.yaml",
				Content: yamlContent,
				SHA:     "mock-sha",
			},
		},
	}

	// Create sync
	mapper := NewGitHubMapper(tmpDir)
	sync := NewGitHubSync(mockClient, repo, mapper, ConflictRemoteWins)

	// Pull
	ctx := context.Background()
	result, err := sync.Pull(ctx, "testuser", "test-repo", "main")

	assert.NoError(t, err)
	assert.Equal(t, 0, result.Pushed)
	assert.Equal(t, 1, result.Pulled)
	assert.Len(t, result.Conflicts, 0)
	assert.Len(t, result.Errors, 0)

	// Verify element was created locally
	element, err := repo.GetByID("skill_TestSkill_20240101-120000")
	assert.NoError(t, err)
	assert.NotNil(t, element)
	assert.Equal(t, "skill_TestSkill_20240101-120000", element.GetID())
	assert.Equal(t, domain.ElementType("skill"), element.GetType())
}

func TestGitHubSync_ConflictDetection(t *testing.T) {
	repo, tmpDir := setupTestRepo(t)
	defer os.RemoveAll(tmpDir)

	// Create local element
	element := createTestElement("persona", "testuser")
	err := repo.Create(element)
	require.NoError(t, err)
	elementID := element.GetID()

	// Get the YAML content
	stored, err := repo.GetByID(elementID)
	require.NoError(t, err)
	storedElement := elementToStoredElement(stored)
	localYAML, err := repo.MarshalElement(storedElement)
	require.NoError(t, err)

	// Create different remote content (simulating conflict)
	remoteYAML := string(localYAML) + "\n# Modified remotely\n"

	// Mock GitHub client with different content
	date := time.Now().Format("2006-01-02")
	remotePath := "elements/testuser/persona/" + date + "/" + elementID + ".yaml"
	mockClient := &mockGitHubClient{
		files: map[string]*infrastructure.FileContent{
			remotePath: {
				Path:    remotePath,
				Content: remoteYAML,
				SHA:     "remote-sha",
			},
		},
	}

	// Create sync
	mapper := NewGitHubMapper(tmpDir)
	sync := NewGitHubSync(mockClient, repo, mapper, ConflictLocalWins)

	// Push with conflict detection
	ctx := context.Background()
	result, err := sync.Push(ctx, "testuser", "test-repo", "main")

	assert.NoError(t, err)
	assert.Len(t, result.Conflicts, 1)

	// Verify conflict details
	conflict := result.Conflicts[0]
	assert.Equal(t, remotePath, conflict.Path)
	assert.NotEmpty(t, conflict.LocalContent)
	assert.NotEmpty(t, conflict.RemoteContent)
	assert.NotEqual(t, conflict.LocalHash, conflict.RemoteHash)
}

func TestGitHubSync_ConflictResolution_LocalWins(t *testing.T) {
	repo, tmpDir := setupTestRepo(t)
	defer os.RemoveAll(tmpDir)

	// Create local element
	element := createTestElement("skill", "testuser")
	err := repo.Create(element)
	require.NoError(t, err)
	elementID := element.GetID()

	// Get local YAML
	stored, err := repo.GetByID(elementID)
	require.NoError(t, err)
	storedElement := elementToStoredElement(stored)
	localYAML, err := repo.MarshalElement(storedElement)
	require.NoError(t, err)

	// Create remote content
	remoteYAML := string(localYAML) + "\n# Remote modification\n"
	date := time.Now().Format("2006-01-02")
	remotePath := "elements/testuser/skill/" + date + "/" + elementID + ".yaml"

	mockClient := &mockGitHubClient{
		files: map[string]*infrastructure.FileContent{
			remotePath: {
				Path:    remotePath,
				Content: remoteYAML,
				SHA:     "remote-sha",
			},
		},
	}

	mapper := NewGitHubMapper(tmpDir)
	sync := NewGitHubSync(mockClient, repo, mapper, ConflictLocalWins)

	// Push with ConflictLocalWins - should update remote with local content
	ctx := context.Background()
	result, err := sync.Push(ctx, "testuser", "test-repo", "main")

	assert.NoError(t, err)
	// With ConflictLocalWins, we should update the remote file
	assert.Equal(t, 1, result.Pushed)
	assert.Len(t, result.Conflicts, 1) // Conflict detected but resolved

	// Verify remote was updated with local content
	updatedFile := mockClient.files[remotePath]
	assert.NotNil(t, updatedFile)
	// Don't compare exact content as timestamps may differ slightly
	assert.Contains(t, updatedFile.Content, elementID)
	assert.Contains(t, updatedFile.Content, "testuser")
}

func TestGitHubSync_ConflictResolution_RemoteWins(t *testing.T) {
	repo, tmpDir := setupTestRepo(t)
	defer os.RemoveAll(tmpDir)

	// Create local element
	element := createTestElement("persona", "testuser")
	err := repo.Create(element)
	require.NoError(t, err)
	elementID := element.GetID()

	// Get local YAML
	stored, err := repo.GetByID(elementID)
	require.NoError(t, err)
	storedElement := elementToStoredElement(stored)
	localYAML, err := repo.MarshalElement(storedElement)
	require.NoError(t, err)

	// Create different remote content
	remoteYAML := string(localYAML) + "\n# Remote is newer\n"
	date := time.Now().Format("2006-01-02")
	remotePath := "elements/testuser/persona/" + date + "/" + elementID + ".yaml"

	mockClient := &mockGitHubClient{
		files: map[string]*infrastructure.FileContent{
			remotePath: {
				Path:    remotePath,
				Content: remoteYAML,
				SHA:     "remote-sha",
			},
		},
	}

	mapper := NewGitHubMapper(tmpDir)
	sync := NewGitHubSync(mockClient, repo, mapper, ConflictRemoteWins)

	// Push with ConflictRemoteWins - should NOT update remote
	ctx := context.Background()
	result, err := sync.Push(ctx, "testuser", "test-repo", "main")

	assert.NoError(t, err)
	assert.Equal(t, 0, result.Pushed) // Should not push
	assert.Len(t, result.Conflicts, 1)

	// Verify remote content unchanged
	unchangedFile := mockClient.files[remotePath]
	assert.Equal(t, remoteYAML, unchangedFile.Content)
}

func TestGitHubSync_ConflictResolution_Manual(t *testing.T) {
	repo, tmpDir := setupTestRepo(t)
	defer os.RemoveAll(tmpDir)

	// Create local element
	element := createTestElement("skill", "testuser")
	err := repo.Create(element)
	require.NoError(t, err)
	elementID := element.GetID()

	// Get local YAML
	stored, err := repo.GetByID(elementID)
	require.NoError(t, err)
	storedElement := elementToStoredElement(stored)
	localYAML, err := repo.MarshalElement(storedElement)
	require.NoError(t, err)

	// Create remote content
	remoteYAML := string(localYAML) + "\n# Needs manual resolution\n"
	date := time.Now().Format("2006-01-02")
	remotePath := "elements/testuser/skill/" + date + "/" + elementID + ".yaml"

	mockClient := &mockGitHubClient{
		files: map[string]*infrastructure.FileContent{
			remotePath: {
				Path:    remotePath,
				Content: remoteYAML,
				SHA:     "remote-sha",
			},
		},
	}

	mapper := NewGitHubMapper(tmpDir)
	sync := NewGitHubSync(mockClient, repo, mapper, ConflictManual)

	// Push with ConflictManual - should stop and report conflict
	ctx := context.Background()
	result, err := sync.Push(ctx, "testuser", "test-repo", "main")

	assert.NoError(t, err)
	assert.Equal(t, 0, result.Pushed) // Should not push
	assert.Len(t, result.Conflicts, 1)

	// Verify conflict has both versions
	conflict := result.Conflicts[0]
	assert.NotEmpty(t, conflict.LocalContent)
	assert.NotEmpty(t, conflict.RemoteContent)
	assert.NotEqual(t, conflict.LocalHash, conflict.RemoteHash)
}

func TestGitHubSync_SyncBidirectional(t *testing.T) {
	repo, tmpDir := setupTestRepo(t)
	defer os.RemoveAll(tmpDir)

	// Create local element
	localElement := createTestElement("persona", "testuser")
	err := repo.Create(localElement)
	require.NoError(t, err)
	localElementID := localElement.GetID()

	// Create remote element
	remoteYAML := `metadata:
  id: skill_RemoteSkill_20240101-000000
  type: skill
  name: Remote Skill
  description: Created remotely
  version: 1.0.0
  author: testuser
  tags:
    - remote
  is_active: true
  created_at: 2024-01-01T00:00:00Z
  updated_at: 2024-01-01T00:00:00Z
`
	remoteElementID := "skill_RemoteSkill_20240101-000000"
	mockClient := &mockGitHubClient{
		files: map[string]*infrastructure.FileContent{
			"elements/testuser/skill/2024-01-01/" + remoteElementID + ".yaml": {
				Path:    "elements/testuser/skill/2024-01-01/" + remoteElementID + ".yaml",
				Content: remoteYAML,
				SHA:     "remote-sha",
			},
		},
	}

	mapper := NewGitHubMapper(tmpDir)
	sync := NewGitHubSync(mockClient, repo, mapper, ConflictNewerWins)

	// Bidirectional sync
	ctx := context.Background()
	result, err := sync.SyncBidirectional(ctx, "testuser", "test-repo", "main")

	assert.NoError(t, err)
	assert.GreaterOrEqual(t, result.Pulled, 1, "Should pull at least the remote element")
	assert.GreaterOrEqual(t, result.Pushed, 1, "Should push at least the local element")
	assert.Len(t, result.Errors, 0)

	// Verify remote element was pulled
	pulledElement, err := repo.GetByID(remoteElementID)
	assert.NoError(t, err)
	assert.NotNil(t, pulledElement)
	assert.Equal(t, "Remote Skill", pulledElement.GetMetadata().Name)

	// Verify local element was pushed
	date := time.Now().Format("2006-01-02")
	expectedPath := "elements/testuser/persona/" + date + "/" + localElementID + ".yaml"
	assert.Contains(t, mockClient.files, expectedPath)
}

func TestGitHubSync_EmptyRepository(t *testing.T) {
	repo, tmpDir := setupTestRepo(t)
	defer os.RemoveAll(tmpDir)

	mockClient := &mockGitHubClient{
		files: make(map[string]*infrastructure.FileContent),
	}

	mapper := NewGitHubMapper(tmpDir)
	sync := NewGitHubSync(mockClient, repo, mapper, ConflictLocalWins)

	// Push with empty repository
	ctx := context.Background()
	result, err := sync.Push(ctx, "testuser", "test-repo", "main")

	assert.NoError(t, err)
	assert.Equal(t, 0, result.Pushed)
	assert.Equal(t, 0, result.Pulled)
	assert.Len(t, result.Conflicts, 0)
	assert.Len(t, result.Errors, 0)
}

func TestGitHubSync_MultipleElements(t *testing.T) {
	repo, tmpDir := setupTestRepo(t)
	defer os.RemoveAll(tmpDir)

	// Create multiple local elements
	for i := 1; i <= 3; i++ {
		element := createTestElement("persona", "testuser")
		err := repo.Create(element)
		require.NoError(t, err)
		// Sleep to ensure unique timestamps in IDs (GenerateElementID uses second precision)
		if i < 3 {
			time.Sleep(1100 * time.Millisecond)
		}
	}

	mockClient := &mockGitHubClient{
		files: make(map[string]*infrastructure.FileContent),
	}

	mapper := NewGitHubMapper(tmpDir)
	sync := NewGitHubSync(mockClient, repo, mapper, ConflictLocalWins)

	// Push all elements
	ctx := context.Background()
	result, err := sync.Push(ctx, "testuser", "test-repo", "main")

	assert.NoError(t, err)
	assert.Equal(t, 3, result.Pushed)
	assert.Len(t, result.Errors, 0)
}
